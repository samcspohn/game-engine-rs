#version 450
#include "util.glsl"

layout(set = 0, binding = 0) uniform Data {
    int num_jobs;
    int stage;   // dont need to update light if off screen
    // mat4 view;
    // mat4 proj;
};

// layout(set = 0, binding = 0) buffer p { vec4 to_buffer[]; };
layout(set = 0, binding = 1) buffer l { light lights[]; };
layout(set = 0, binding = 2) buffer ld { light_deinit deinits[]; };
layout(set = 0, binding = 3) buffer li { light_init inits[]; };
layout(set = 0, binding = 4) buffer tr { transform transforms[]; };
layout(set = 0, binding = 5) buffer b { uint buckets[]; };
layout(set = 0, binding = 6) buffer bc { uint buckets_count[]; };
layout(set = 0, binding = 7) buffer b2 { uint buckets2[]; };
// copy buckets to buckets 2 between steps 3 & 4
layout(set = 0, binding = 8) buffer lid { uint light_ids[]; };
// layout(set = 0, binding = 9) buffer h { uint[8] hashes[]; };

// layout(set = 0, binding = 3) buffer _t { int transform_ids[]; };

// struct light {
//  int templ;
// 	int t_id;
//  int enabled;
// 	int hash;
// };
const uint num_buckets = 65536;
const float skip_size = float(num_buckets) / 256.0;
// shared uint[128] local_sums;   // TODO: increase local sums

// bool hash_doesnt_exist(uint id, uint hash, uint curr_hash) {
//     for (int a = 0; a < curr_hash; ++a) {
//         if (hashes[id][a] == hash) {
//             return false;
//         };
//     }
//     return true;
// }
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main() {
    const uint id = gl_GlobalInvocationID.x;
    if (id < num_jobs) {
        switch (stage) {
        case 0: {   // deinit
            light_deinit di = deinits[id];
            lights[di.id].enabled = 0;
        } break;
        case 1: {   // init
            light_init li = inits[id];
            lights[li.id].t_id = li.t_id;
            lights[li.id].templ = li.templ_id;
            lights[li.id].enabled = 1;
        } break;
        case 2: {   // calc buckets
            if (lights[id].enabled == 0) break;

            // uint hashes[8] = {0, 0, 0, 0, 0, 0, 0, 0};
            // hashes[id] = {-1, -1, -1, -1, -1, -1, -1, -1};
            // for (int i = 0; i < 8; ++i)
            //     hashes[id][i] = -1;
            vec3 pos = transforms[lights[id].t_id].position;
            uint main_hash = hash_pos(pos);
            float radius = 8;
            lights[id].pos = pos;
            lights[id].hash = main_hash;
            lights[id].radius = radius;
            atomicAdd(buckets_count[main_hash], 1);
            // atomicAdd(buckets[main_hash], 1);

            // hashes[id][0] = main_hash;
            // uint curr_hash = 0;
            // for (int x = -1; x <= 1; x += 2) {
            //     for (int y = -1; y <= 1; y += 2) {
            //         for (int z = -1; z <= 1; z += 2) {
            //             uint hash = hash_pos(pos + vec3(x, y, z) * radius);
            //             // bool b = true;
            //             // for (int a = 0; a < curr_hash; ++a) {
            //             //     if (hashes[id][a] == hash) {
            //             //         b = false;
            //             //         break;
            //             //     };
            //             // }
            //             if (hash_doesnt_exist(id, hash, curr_hash)) {
            //                 hashes[id][curr_hash] = hash;
            //                 curr_hash += 1;
            //                 // atomicAdd(buckets_count[hash], 1);
            //             }
            //         }
            //     }
            // }
            // for (int i = 0; i < 8; ++i) {
            //     uint hash = hashes[id][i];
            //     if (hash == -1) break;
            //     atomicAdd(buckets_count[hash], 1);
            // }
        } break;
        // copy buckets_count to buckets
        case 3: {   // prefix sum
            // if (id > 0) break;
            // uint temp = buckets[0];
            // buckets[0] = 0;
            // for (int i = 1; i < 65536; ++i) {
            //     uint temp2 = buckets[i];
            //     buckets[i] = temp;
            //     temp += temp2;
            // }

            // uint start = id * skip_size;
            // uint end = (id + 1) + skip_size;
            // uint local_sum = buckets[start];
            // buckets[start] = 0;
            // for (uint i = start + 1; i < end; ++i) {
            //     uint temp = buckets[i];
            //     buckets[i] = local_sum;
            //     local_sum += temp;
            // }
            // buckets[num_buckets + id] = local_sum;

            uint x = id;
            uint start = uint(float(x) * skip_size);
            uint end = uint(float(x + 1) * skip_size);
            if (x == 255) end = num_buckets;
            uint local_sum = buckets[start];
            buckets[start] = 0;
            for (uint i = start + 1; i < end; ++i) {
                uint temp = buckets[i];
                buckets[i] = local_sum;
                local_sum += temp;
            }
            buckets[num_buckets + x] = local_sum;
            // uint start = x * skip_size;
            // uint end = (x + 1) * skip_size;
            // if (id == num_jobs - 1) {
            //     end = num_buckets;
            // }
            // uint local_sum = buckets[start];
            // buckets[start] = 0;
            // for (uint i = start + 1; i < end; ++i) {
            //     uint temp = buckets[i];
            //     buckets[i] = local_sum;
            //     local_sum += temp;
            // }
            // buckets[num_buckets + x] = local_sum;
        } break;
        case 5: {
            if (id > 0) break;
            // uint temp = buckets[0];
            // buckets[0] = 0;
            // for (int i = 1; i < num_buckets; ++i) {
            //     uint temp2 = buckets[i];
            //     buckets[i] = temp;
            //     // buckets2[i] = buckets[i];
            //     temp += temp2;
            // }


            // for (uint x = 0; x < 256; ++x) {
            //     uint start = uint(float(x) * skip_size);
            //     uint end = uint(float(x + 1) * skip_size);
            //     if (x == 255) end = num_buckets;
            //     uint local_sum = buckets[start];
            //     buckets[start] = 0;
            //     for (uint i = start + 1; i < end; ++i) {
            //         uint temp = buckets[i];
            //         buckets[i] = local_sum;
            //         local_sum += temp;
            //     }
            //     buckets[num_buckets + x] = local_sum;
            // }
            {
                uint start = num_buckets;
                uint end = num_buckets + 256;
                uint sum = buckets[start];
                buckets[start] = 0;
                for (uint i = start + 1; i < end; ++i) {
                    uint temp = buckets[i];
                    buckets[i] = sum;
                    sum += temp;
                }
            }
            // for (uint x = 0; x < 256; ++x) {
            //     uint offset = buckets[num_buckets + x];
            //     uint start = uint(float(x) * skip_size);
            //     uint end = uint(float(x + 1) * skip_size);
            //     // uint local_sum = buckets[start];
            //     for (uint i = start; i < end; ++i) {
            //         buckets[i] += offset;
            //     }
            // }
            // for(uint i = 0; i < num_buckets; ++i){
            //     buckets[i] += buckets[num_buckets + i / 256];
            //     buckets2[i] = buckets[i];
            // }

            // uint sum = buckets[num_buckets + 0];
            // for (uint i = 1; i < 256; i++) {
            //     uint temp = buckets[num_buckets + i];
            //     buckets[num_buckets + i] = sum;
            //     sum += temp;
            // }
        } break;
        case 6: {
            uint x = id;
            uint offset = buckets[num_buckets + x];
            uint start = uint(float(x) * skip_size);
            uint end = uint(float(x + 1) * skip_size);
            if (x == 255) end = num_buckets;
            // uint local_sum = buckets[start];
            for (uint i = start; i < end; ++i) {
                buckets[i] += offset;
            }
            // uint start = id * 256;
            // uint end = (id + 1) * 256;
            // // uint local_sum = buckets[start];
            // for (uint i = start; i < end; ++i) {
            //     buckets[i] += buckets[num_buckets + id];
            // }
            // buckets[id] += buckets[num_buckets + id / 256];
            // buckets2[id] = buckets[id];

        } break;
        // copy buckets
        case 4: {
            if (lights[id].enabled == 0) break;

            uint i = atomicAdd(buckets2[lights[id].hash], 1);
            light_ids[i] = id;
            // uint curr_hash = 0;
            // uint hash = -1;
            // do {
            //     hash = hashes[id][curr_hash];
            //     uint i = atomicAdd(buckets2[hash], 1);
            //     light_ids[i] = id;
            //     curr_hash += 1;
            // } while (hash != -1 && curr_hash < 8);

        } break;
        }
    }
}