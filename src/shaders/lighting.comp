#version 450

#include "util.glsl"

// struct ClusterNode {
//     uint count;
//     uint offset;
// };
layout(set = 0, binding = 0) uniform Data {
    int num_jobs;
    int stage;
    vec3 cam_pos;
};

// layout(set = 0, binding = 0) buffer p { vec4 to_buffer[]; };
layout(set = 0, binding = 1) buffer l { light lights[]; };
layout(set = 0, binding = 2) buffer ld { light_deinit deinits[]; };
layout(set = 0, binding = 3) buffer li { light_init inits[]; };
layout(set = 0, binding = 4) buffer tr { transform transforms[]; };
layout(set = 0, binding = 6) buffer lt { lightTemplate templates[]; };
layout(set = 0, binding = 7) buffer t { tile tiles[]; };

layout(set = 0, binding = 8) buffer ltid { uint light_tile_ids[]; };
layout(set = 0, binding = 15) buffer ll { uint light_ids[]; };
// layout(set = 0, binding = 8) buffer ll { ivec2 light_list[]; };
layout(set = 0, binding = 16) buffer ltid2 { uint light_tile_ids2[]; };
layout(set = 0, binding = 9) buffer ll2 { uint light_list2[]; };
// layout(set = 0, binding = 10) buffer lo { uint light_offsets[]; };

struct PC {
    uint g_num_elements;
    uint g_num_workgroups;
};
layout(std430, set = 0, binding = 11) buffer lc { PC pc; };
layout(set = 0, binding = 12) buffer vl { uint visible_lights[]; };
layout(set = 0, binding = 13) buffer vlc { uint visible_lights_c; };
layout(set = 0, binding = 14) buffer i { DispatchIndirectCommand indirect[]; };

layout(std430, set = 0, binding = 10) buffer blh_ { BoundingLine blh[]; };   // (num_lights * 4)

shared uint local_offsets[128 * 2];
shared int local_BLH_offsets[128 * 2];
// shared uvec2 local_indeces[128 * 4];
shared uint local_tile_ids[128 * 4];
shared uint local_light_ids[128 * 4];
// shared float local_distances[128 * 4];
// shared uint local_counts[_light_quadtree_offsets[MAX_LEVEL]];
shared uint local_counter;
shared uint global_idx;
const ivec2 index_offsets[4] = {ivec2(0), ivec2(0, 1), ivec2(1, 0), ivec2(1)};   // -1?

void traverse_quadtree(inout ivec3 a[4], inout int a_c, vec3 pos, float radius) {
    ivec3 b[4];
    int b_c = 0;
    for (int level = 2; level < MAX_LEVEL; ++level) {   // iterate through levels
        b_c = 0;
        for (int i = 0; i < a_c; i++) {
            int index = get_tile(a[i].x, a[i].y, a[i].z);
            atomicAdd(tiles[index].travel_through, 1);
        }
        for (int j = 0; j < a_c; ++j) {   // iterate through collided parents
            ivec2 tile_c = a[j].xy * 2;
            for (int k = 0; k < 4; ++k) {   // iterate through 4 quadtree children
                ivec2 _tile_c = tile_c + index_offsets[k];
                int index = get_tile(_tile_c.x, _tile_c.y, level);
                if (sphere_frustum(pos, radius, tiles[index].frustum)) {
                    if (b_c >= 4) {
                        return;
                    }
                    b[b_c] = ivec3(_tile_c, level);
                    ++b_c;
                }
            }
        }
        a = b;
        a_c = b_c;
    }
    return;
}

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main() {
    const uint id = gl_GlobalInvocationID.x;
    if (id < num_jobs) {
        switch (stage) {
        case 0: {   // deinit
            light_deinit di = deinits[id];
            lights[di.id].enabled = 0;
        } break;
        case 1: {   // init
            light_init li = inits[id];
            lights[li.id].t_id = li.t_id;
            lights[li.id].templ = li.templ_id;
            lights[li.id].enabled = 1;
        } break;
        case 2: {

            if (lights[id].enabled == 0) break;
            vec3 pos = transforms[lights[id].t_id].position;
            vec3 color = templates[lights[id].templ].color;
            attenuation att = templates[lights[id].templ].atten;
            float lightMax = max(max(color.r, color.g), color.b) * att.brightness;
            float radius =
                (-att.linear + sqrt(att.linear * att.linear - 4 * att.exponential * (att.constant - (256.0 / 4.0) * lightMax))) / (2 * att.exponential);
            lights[id].pos = pos;
            lights[id].radius = radius;

        } break;
        case 3: {   // generate light list
            if (gl_LocalInvocationID.x == 0) {
                local_counter = 0;
            }
            barrier();
            vec3 pos = lights[id].pos;
            float radius = lights[id].radius;
            if (lights[id].enabled == 1 && sphere_frustum(pos, radius, tiles[get_tile(0, 0, 0)].frustum)) {   // full camera frustum
                uint idx = atomicAdd(local_counter, 1);
                local_offsets[idx] = id;
            }
            barrier();
            if (gl_LocalInvocationID.x == 0) {
                global_idx = atomicAdd(visible_lights_c, local_counter);
            }
            barrier();
            if (gl_LocalInvocationID.x < local_counter) {
                visible_lights[global_idx + gl_LocalInvocationID.x] = local_offsets[gl_LocalInvocationID.x];
            }
            atomicMax(indirect[0].x, (global_idx + local_counter) / 128 + 1);
        } break;
        case 4: {
            if (gl_WorkGroupID.x > visible_lights_c / gl_WorkGroupSize.x + 1) {   // dispatch indirect
                return;
            }
            uint local_id = gl_LocalInvocationID.x;
            if (local_id == 0) {
                local_counter = 0;
            }
            barrier();
            if (id < visible_lights_c) {
                uint light_id = visible_lights[id];

                vec3 pos = lights[light_id].pos;
                float radius = lights[light_id].radius;
                float light_dist = distance(cam_pos, pos);
                ivec3 a[4];
                int a_c = 0;
                for (int x = 0; x < 4; ++x) {   // entrance, first level
                    ivec2 c = index_offsets[x];
                    if (sphere_frustum(pos, radius, tiles[get_tile(c.x, c.y, 1)].frustum)) {   // level 1 since level 0 is full camera frustum
                        a[a_c] = ivec3(c.x, c.y, 1);
                        ++a_c;
                    }
                }
                traverse_quadtree(a, a_c, pos, radius);

                uint local_idx = atomicAdd(local_counter, a_c);
                for (int i = 0; i < a_c; ++i) {
                    ivec3 _a = a[i];
                    uint tile_idx = uint(get_tile(_a.x, _a.y, _a.z));
                    uint tile_id_dist = tile_idx << 19 | (((floatBitsToUint(light_dist) ^ (1 << 31)) >> 13) & 0x7FFFF);
                    // local_indeces[local_idx + i] = uvec2(tile_idx, light_id);
                    local_tile_ids[local_idx + i] = tile_id_dist;
                    local_light_ids[local_idx + i] = light_id;
                    atomicAdd(tiles[tile_idx].count, 1);
                }
            }

            barrier();
            if (local_id == 0) {
                global_idx = atomicAdd(pc.g_num_elements, local_counter);
            }
            barrier();
            local_id = local_id * 4;
            for (int i = 0; i < 4; ++i) {
                if (local_id + i < local_counter) {
                    light_tile_ids[global_idx + local_id + i] = local_tile_ids[local_id + i];
                    light_ids[global_idx + local_id + i] = local_light_ids[local_id + i];
                }
            }
            barrier();
            if (local_id == 0) {
                // atomicMax(indirect[0].x, (global_idx + local_counter) / 128 + 1);
                uint num_elements = global_idx + local_counter;
                const uint num_blocks_per_workgroup = 32;
                const uint work_group_size = 256;
                uint dispatch_size = uint(ceil(float(num_elements / float(num_blocks_per_workgroup))));
                uint num_workgroups = uint(ceil(float(dispatch_size) / float(work_group_size)));
                atomicMax(indirect[0].x, num_workgroups);
                atomicMax(pc.g_num_workgroups, num_workgroups);
            }

        } break;
        case 5: {   // prefix sum / sort
            const float num_tiles = _light_quadtree_offsets[MAX_LEVEL];
            const float num_threads = gl_WorkGroupSize.x;

            // if (gl_LocalInvocationID.x == 0) {
            //     uint total = tiles[0].count;
            //     tiles[0].offset = 0;
            //     light_offsets[0] = 0;
            //     for (int i = 1; i < num_tiles; ++i) {
            //         tiles[i].offset = total;
            //         light_offsets[i] = total;
            //         total += tiles[i].count;
            //     }
            // }
            // return;
            // 1364 tiles (max 32x32 tiles)
            // 1 work group = 128 threads

            uint local_id = gl_LocalInvocationID.x;
            int start = int(local_id * (num_tiles / num_threads));
            int end = int((local_id + 1) * (num_tiles / num_threads));

            uint temp = tiles[start].count;
            int BLH_temp = int(max(int(tiles[start].count) - 1, 0));
            tiles[start].offset = 0;
            tiles[start].BLH_offset = 0;
            for (int i = start + 1; i < end; ++i) {
                tiles[i].offset = temp;
                tiles[i].BLH_offset = BLH_temp;
                temp += tiles[i].count;
                BLH_temp += int(max(int(tiles[i].count) - 1, 0));
            }
            local_offsets[id] = temp;
            local_BLH_offsets[id] = BLH_temp;
            barrier();
            if (local_id == 0) {
                uint temp = local_offsets[0];
                int BLH_temp = local_BLH_offsets[0];
                local_offsets[0] = 0;
                for (int i = 1; i < gl_WorkGroupSize.x; i++) {
                    uint temp2 = local_offsets[i];
                    int temp3 = local_BLH_offsets[i];
                    local_offsets[i] = temp;
                    local_BLH_offsets[i] = BLH_temp;
                    temp += temp2;
                    BLH_temp += temp3;
                }
            }
            barrier();
            for (int i = start; i < end; ++i) {
                tiles[i].offset += local_offsets[id];
                tiles[i].BLH_offset += local_BLH_offsets[id] + 1;   // offset all blh by 1 / sacrifice 1 blh
                // light_offsets[i] = tiles[i].offset;
            }
            // offsets point to BLH or light ids
        } break;
        case 6: {   // reorder
            if (id < pc.g_num_elements) {
                uint index = atomicAdd(tiles[light_tile_ids[id] >> 19].count, 1);
                light_tile_ids2[index] = light_tile_ids[id];
                light_list2[index] = light_ids[id];
            }
        } break;
        case 7: {
            if (id < num_jobs) {
                blh[id].flag = 0;
                // set start to max float value
                // blh[id].start = 3.402823466e+38;
                // blh[id].start1 = 3.402823466e+38;
                // blh[id].start2 = 3.402823466e+38;
                // set end to min float value
                // blh[id].end = -3.402823466e+38;
                // blh[id].end1 = -3.402823466e+38;
                // blh[id].end2 = -3.402823466e+38;
            }
        } break;
        case 8: {   // calculate BLH
            if (id < pc.g_num_elements) {
                uint tile_id = light_tile_ids2[id] >> 19;
                uint light_id = light_list2[id];

                float dist = distance(cam_pos, lights[light_id].pos);
                float start = dist - lights[light_id].radius;
                float end = dist + lights[light_id].radius;

                int light_count = int(tiles[tile_id].count);
                int light_offset = int(tiles[tile_id].offset);
                int blh_count = int(max(int(tiles[tile_id].count) - 1, 0));
                int blh_offset = tiles[tile_id].BLH_offset;
                int blh_end = blh_offset + blh_count;
                int blh_value = -int(light_id);

                if (blh_count == 0) {
                    tiles[tile_id].BLH_offset = blh_value;
                    return;
                }

                uint local_id = gl_LocalInvocationID.x;
                int curr_id = int(id) - light_offset;
                int blh_id = curr_id / 2;
                
                int level_size = light_count / 2;
                int level_remainder = blh_count > 1 ? light_count % 2 : 0;

                while (level_size > 0) {
                    if (blh_id < level_size) {
                        if(curr_id % 2 == 0) {
                            blh[blh_offset + blh_id].front = blh_value;
                            blh[blh_offset + blh_id].start1 = start;
                            blh[blh_offset + blh_id].end1 = end;
                            
                        } else {
                            blh[blh_offset + blh_id].back = blh_value;
                            blh[blh_offset + blh_id].start2 = start;
                            blh[blh_offset + blh_id].end2 = end;
                        }
                        uint flag = atomicAdd(blh[blh_offset + blh_id].flag, 1);
                        if (flag == 0) {
                            return;
                        }
                        blh[blh_offset + blh_id].start = min(blh[blh_offset + blh_id].start1, blh[blh_offset + blh_id].start2);
                        blh[blh_offset + blh_id].end = max(blh[blh_offset + blh_id].end1, blh[blh_offset + blh_id].end2);
                        blh_value = blh_offset + blh_id;
                        start = blh[blh_offset + blh_id].start;
                        end = blh[blh_offset + blh_id].end;
                    }
                    curr_id = blh_id;
                    blh_id /= 2;
                    if (blh_offset + level_size >= blh_end) {
                        break;
                    }
                    blh_offset += level_size;
                    level_remainder = (level_size + level_remainder) % 2;
                    level_size = (level_size + level_remainder) / 2;
                }
                tiles[tile_id].BLH_offset = blh_offset;


                // uint local_id = gl_LocalInvocationID.x;
                // uint tile_id = light_tile_ids2[id] >> 19;
                // if (tile_id >= tiles.length()) {
                //     return;
                // }
                // uint light_id = light_list2[id];

                // float dist = distance(cam_pos, lights[light_id].pos);
                // float start = dist - lights[light_id].radius;
                // float end = dist + lights[light_id].radius;
                // uint light_offset = tiles[tile_id].offset;
                // int BLH_offset = tiles[tile_id].BLH_offset;
                // int BLH_count = int(max(int(tiles[tile_id].count) - 1, 0));
                // int BLH_end = BLH_offset + BLH_count;
                
                // int level_size = BLH_count / 2;
                // int level_remainder = BLH_count % 2;
                // uint local_light_id = id - light_offset;
                // uint curr_level_id = local_light_id / 2;
                // uint BLH_id = BLH_offset + curr_level_id;
                // int blh_value = -int(light_id);
                // // return;
                // if (BLH_count == 0) {
                //     tiles[tile_id].BLH_offset = -int(light_id);
                //     return;
                // }

                // uint num_iter = 0;
                // while (BLH_offset < BLH_end || level_size > 0) {
                //     if (BLH_id >= blh.length()) {
                //         return;
                //     }
                //     if (curr_level_id < level_size) {   // curr_level_id == BLH_id - BLH_offset
                //         if (local_light_id % 2 == 0) {
                //             blh[BLH_id].front = blh_value;
                //             if (local_id * 4 + 1 < local_distances.length()) {
                //                 local_distances[local_id * 4] = start;
                //                 local_distances[local_id * 4 + 1] = end;
                //             }

                //             if (local_id * 4 + 3 < local_distances.length()) {
                //                 local_distances[local_id * 4 + 2] = start;
                //                 local_distances[local_id * 4 + 3] = end;
                //             }
                //             local_distances[local_id * 4 + 2] = start;
                //             local_distances[local_id * 4 + 3] = end;
                //         }
                //         uint flag = atomicAdd(blh[BLH_id].flag, 1);
                //         if (flag == 0) {
                //             return;
                //         }
                //         blh[BLH_id].start = min(local_distances[local_id * 4], local_distances[local_id * 4 + 2]);
                //         blh[BLH_id].end = max(local_distances[local_id * 4 + 1], local_distances[local_id * 4 + 3]);
                //         blh_value = int(BLH_id);
                //         start = blh[BLH_id].start;
                //         end = blh[BLH_id].end;
                //     }

                //     local_light_id = curr_level_id;
                //     curr_level_id /= 2;
                //     if ((level_size + level_remainder) == 1) {
                //         break;
                //     }
                //     BLH_offset += level_size;
                //     BLH_id = BLH_offset + curr_level_id;
                //     level_remainder = (level_size + level_remainder) % 2;
                //     level_size = (level_size + level_remainder) / 2;
                //     num_iter++;
                // }
                // tiles[tile_id].BLH_offset = BLH_offset;   // update BLH offset
            }
        } break;
        default:
            break;
        }
    }
}