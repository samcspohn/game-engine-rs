#version 450
#include "util.glsl"

// struct ClusterNode {
//     uint count;
//     uint offset;
// };
layout(set = 0, binding = 0) uniform Data {
    int num_jobs;
    int stage;   // dont need to update light if off screen
};

// layout(set = 0, binding = 0) buffer p { vec4 to_buffer[]; };
layout(set = 0, binding = 1) buffer l { light lights[]; };
layout(set = 0, binding = 2) buffer ld { light_deinit deinits[]; };
layout(set = 0, binding = 3) buffer li { light_init inits[]; };
layout(set = 0, binding = 4) buffer tr { transform transforms[]; };
layout(set = 0, binding = 6) buffer lt { lightTemplate templates[]; };

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void main() {
    const uint id = gl_GlobalInvocationID.x;
    if (id < num_jobs) {
        switch (stage) {
        case 0: {   // deinit
            light_deinit di = deinits[id];
            lights[di.id].enabled = 0;
        } break;
        case 1: {   // init
            light_init li = inits[id];
            lights[li.id].t_id = li.t_id;
            lights[li.id].templ = li.templ_id;
            lights[li.id].enabled = 1;
        } break;
        case 2: {
            if (lights[id].enabled == 0) break;
            vec3 pos = transforms[lights[id].t_id].position;
            vec3 color = templates[lights[id].templ].color;
            attenuation att = templates[lights[id].templ].atten;
            float lightMax = max(max(color.r, color.g), color.b) * att.brightness;
            float radius =
                (-att.linear + sqrt(att.linear * att.linear - 4 * att.exponential * (att.constant - (256.0 / 5.0) * lightMax))) / (2 * att.exponential);
            lights[id].pos = pos;
            lights[id].radius = radius;

        } break;
        }
    }
}