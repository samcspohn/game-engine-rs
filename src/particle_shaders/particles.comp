#version 450
#include "../util.glsl"
#include "particle.glsl"
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct transform {
    vec3 position;
    vec4 rotation;
    vec3 scale;
};


struct emitter {
    // vec3 pos;
    int alive;
    int transform_id;
    float emission;
    int template_id;
};

struct emitter_init {
    int transform_id;
    int alive;
    int template_id;
    int e_id;
};
// struct particle_emitter_prototype {

// };


layout(set = 0, binding = 0) buffer t {
    transform transforms[];
};
layout(set = 0, binding = 1) buffer p {
    particle particles[];
};
layout(set = 0, binding = 2) buffer _p {
    pos_lif p_l[];
};
layout(set = 0, binding = 9) buffer pt {
    int template_ids[];
};
// layout(set = 0, binding = 3) buffer l {
//     float life[];
// };
layout(set = 0, binding = 4) buffer a {
    uint avail[];
};
layout(set = 0, binding = 5) buffer e {
    emitter emitters[];
};
layout(set = 0, binding = 6) buffer a_c {
    int avail_count;
};
layout(set = 0, binding = 7) buffer p_t {
    particle_template templates[];
};

layout(set = 0, binding = 10) buffer e_i {
    emitter_init emitter_inits[];
};

const int MAX_PARTICLES = 8 * 1024 * 1024;


layout(set = 0, binding = 8) uniform Data {
    int num_jobs;
    float dt;
    float time;
    int stage;
    vec3 cam_pos;
    vec4 cam_rot;
    // mat4 view;
};

// vec4 look_at = lookAt(vec3(rotate(cam_rot) * vec4(0,0,1,1)).xyz, 
//         vec3(rotate(cam_rot) * vec4(0.,1,0.,1)).xyz);

vec4 look_at = lookAt(rotate3(cam_rot) * vec3(0,0,1), rotate3(cam_rot) * vec3(0,1,0));

float rand(float i) {
    return cos(sin(float(i) * 8.96 + time * 5.5) + cos(float(i) * 8.96 + time * 5.5));
}

void update_particle(uint id) {
    if(p_l[id].life > 0.0){
        p_l[id].pos += particles[id].vel * dt;
        // particles[id].rot = lookAt(vec3(rotate(cam_rot) * vec4(0,0,-1,1)).xyz, 
        // vec3(rotate(cam_rot) * vec4(0,1,0,1)).xyz);
        particles[id].rot = look_at;
        p_l[id].life -= dt;
        if(p_l[id].life < 0.0) {
            int avail_id = atomicAdd(avail_count,-1);
            avail[avail_id - 1] = id;
        }
    }
}

void update_emitter(uint id) {

    if(emitters[id].alive == 0)
        return;
    particle_template templ = templates[emitters[id].template_id];
    if(emitters[id].emission >= 1.0) {
        int avail_id = min(atomicAdd(avail_count,1),MAX_PARTICLES - 1);
        uint i = avail[avail_id];
        atomicMin(avail_count,MAX_PARTICLES);
        particles[i].vel = normalize(vec3(rand(id + i * 1.2), rand(id + i * 3.4), rand(id + i * 2.4))) * templ.speed;
        template_ids[i] = emitters[id].template_id;
        p_l[i].pos = transforms[emitters[id].transform_id].position;
        p_l[i].life = 1.0;
        emitters[id].emission = 0.0;
    } else {
        emitters[id].emission += templ.emission_rate * dt; // 10 particles/sec
    }
}

void init_emitters(uint id){
    emitter_init init = emitter_inits[id];
    emitter e;
    e.alive = init.alive;
    e.transform_id = init.transform_id;
    e.template_id = init.template_id;
    e.emission = 1.f;
    emitters[init.e_id] = e;


}

void main() {
    uint id = gl_GlobalInvocationID.x;// * (8 * 8) + gl_GlobalInvocationID.y * (8) + gl_GlobalInvocationID.z;
    // transforms[0].position = vec3(0,0,0);
    if(id < num_jobs) {
        switch(stage) {
             case 0:
                init_emitters(id);
                break;
            case 1:
                update_emitter(id);
                break;
            case 2:
                update_particle(id);
                break;
        }
    }
}