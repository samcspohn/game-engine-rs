#version 450
#include "../util.glsl"
#include "particle.glsl"
layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

// struct _a {
//     // vec4 rot;
//     // vec3 pos;
//     uint key;
//     // int proto_id;
//     // float life;
//     int p_id;
// };
struct DispatchIndirectCommand {
    uint x;
    uint y;
    uint z;
};
struct VkDrawIndirectCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};
struct transform {
    vec3 position;
    vec4 rotation;
    vec3 scale;
};

// struct particle {
//     vec3 vel;
//     int emitter_id;
//     int sorted;
// };
// struct particle_template {
//     vec3 color;
//     float speed;
//     float emission_rate;
// };
// struct pos_lif {
//     vec3 pos;
//     float life;
//     vec4 rot;
//     int template_id;
// };

layout(set = 0, binding = 0) buffer _a1 { _a a1[]; };
layout(set = 0, binding = 1) buffer _a2 { int a2[]; };
layout(set = 0, binding = 2) buffer p { particle particles[]; };
layout(set = 0, binding = 3) buffer _p { pos_lif p_l[]; };
layout(set = 0, binding = 4) buffer l { DispatchIndirectCommand indirect[]; };
layout(set = 0, binding = 5) buffer a_c { int avail_count[]; };
layout(set = 0, binding = 6) uniform Data {
    int num_jobs;
    int stage;
    mat4 view;
    mat4 proj;
};
layout(set = 0, binding = 7) buffer b { uint buckets[]; };
layout(set = 0, binding = 8) buffer d { VkDrawIndirectCommand draw[]; };

layout(set = 0, binding = 9) buffer _n { int next[]; };
layout(set = 0, binding = 10) buffer pt { particle_template templates[]; };
layout(set = 0, binding = 11) buffer e { emitter emitters[]; };
layout(set = 0, binding = 12) buffer t { transform transforms[]; };
// shared uint[512] local_buckets;
const uint skip_size = (1 << 16) / 128;
shared uint[128] local_sums;
void main() {
    int id = int(gl_GlobalInvocationID.x);
    int jobs = num_jobs >= 0 ? num_jobs : avail_count[0];

    if (id < jobs) {
        switch (stage) {
        case 0:
            // update sorted for particles
            // particles[a1[id].p_id].sorted = id;
            avail_count[0] = 0;

            break;
        case 1:
            // add particles to sort buffer / update particle keys
            // float z = (view * vec4(p_l[id].pos, 1.0)).z;
            // int i = particles[id].sorted;
            if (p_l[id].life > 0.f) {   // add to sort or update
                vec3 v_pos = (view * vec4(p_l[id].pos, 1.0)).xyz;
                vec4 _vp_pos = (proj * view * vec4(p_l[id].pos, 1.0));
                vec3 vp_pos = _vp_pos.xyz / _vp_pos.w;
                float z = v_pos.z;
                particle_template templ =
                    templates[emitters[particles[id].emitter_id].template_id];
                if (templ.trail == 1) {
                    vec3 next_pos;
                    if (next[id] >= 0) {
                        next_pos = p_l[next[id]].pos;
                    } else if (next[id] < -1) {
                        next_pos = transforms[-next[id] - 2].position;
                    } else {
                        next_pos = p_l[id].pos;
                    }
                    z = (z + (view * vec4(next_pos, 1.0)).z) / 2;
                }
                if (z < 0.f && vp_pos.x > -1.f && vp_pos.x < 1.f &&
                    vp_pos.y > -1.f && vp_pos.y < 1.f) {

                    int i = atomicAdd(avail_count[0], 1);   // elements to sort
                    z = -sqrt(-z);
                    a1[i].key = ~(floatBitsToUint(z) ^ (1 << 31));
                    a1[i].p_id = id;
                    a2[i] = id;
                }
            }
            break;
        case 2:
            if (id == 0) {
                indirect[0].x = avail_count[0] / 1024 +
                                1;   // for 3   MAX_PARTICLES / 128 + 1 ;
                indirect[0].y = 1;
                indirect[0].z = 1;
            }
            buckets[id] = 0;
            break;
        case 3:
            if (id < avail_count[0]) {
                atomicAdd(buckets[a1[id].key >> 16], 1);
            }
            break;
        case 4:
            uint start = id * skip_size;
            uint end = start + skip_size;
            uint temp = buckets[start];
            buckets[start] = 0;
            for (uint i = start + 1; i < end; i++) {
                uint temp2 = buckets[i];
                buckets[i] = temp;
                temp += temp2;
            }
            local_sums[id] = temp;
            barrier();

            if (id == 0) {
                temp = local_sums[0];
                for (uint i = 1; i < 128; i++) {
                    uint temp2 = local_sums[i];
                    local_sums[i] = temp;
                    temp += temp2;
                }
            }
            barrier();
            for (uint i = start; i < end; i++) {
                buckets[i] += local_sums[id];
            }
            break;
        case 5:
            if (id < avail_count[0]) {
                a2[atomicAdd(buckets[a1[id].key >> 16], 1) - 1] = a1[id].p_id;
            }
            break;

        case 6:
            // avail_count[0] -= avail_count[1];
            // avail_count[1] = 0;
            indirect[0].x = avail_count[0] / 128 + 1;   // for 0
            indirect[0].y = 1;
            indirect[0].z = 1;
            draw[0].vertexCount = avail_count[0];   // avail_count[0];
            break;
        }
    }
}
